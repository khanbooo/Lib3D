# !/usr/bin/env python3

import random
import subprocess
import sys
import os

def generate_random_numbers(count, min_val=-1.0, max_val=1.0, precision=1):
    numbers = []
    for _ in range(count):
        num = random.uniform(min_val, max_val)
        num = round(num, precision)
        numbers.append(num)
    return numbers

def generate_random_intersecting_segments():
    # Generating random intersection point
    px = random.uniform(-50, 50)
    py = random.uniform(-50, 50)
    pz = random.uniform(-50, 50)
    
    # Generating first direction
    d1x = random.uniform(-1, 1)
    d1y = random.uniform(-1, 1)
    d1z = random.uniform(-1, 1)
    
    d1_len = (d1x**2 + d1y**2 + d1z**2) ** 0.5
    if d1_len < 0.1: # Quite strong condition for minimal length, but it's okay for the generating purposes
        d1x, d1y, d1z = 1.0, 0.0, 0.0
    else:
        d1x, d1y, d1z = d1x/d1_len, d1y/d1_len, d1z/d1_len
    
    # Trying to generate second direction
    max_attempts = 10
    for _ in range(max_attempts):
        d2x = random.uniform(-1, 1)
        d2y = random.uniform(-1, 1)
        d2z = random.uniform(-1, 1)
        
        d2_len = (d2x**2 + d2y**2 + d2z**2) ** 0.5
        if d2_len < 0.1:
            continue
            
        d2x, d2y, d2z = d2x/d2_len, d2y/d2_len, d2z/d2_len
        
        # Vectors are parallel => dot product equals +- 1
        dot_product = abs(d1x*d2x + d1y*d2y + d1z*d2z)
        if dot_product < 0.95:  # Also quite strong condition for vectors not being parallel
            break
    else:
        # Using perpendicular vector if random generation wasn't successful
        d2x, d2y, d2z = -d1y, d1x, 0.0
        d2_len = (d2x**2 + d2y**2 + d2z**2) ** 0.5
        if d2_len > 0.1:
            d2x, d2y, d2z = d2x/d2_len, d2y/d2_len, d2z/d2_len
        else:
            d2x, d2y, d2z = 0.0, 0.0, 1.0
    
    scale1 = random.uniform(10, 50)
    scale2 = random.uniform(10, 50)
    
    t1 = random.uniform(0.2, 0.8)
    t2 = random.uniform(0.2, 0.8)
    
    s1 = random.uniform(0.2, 0.8)
    s2 = random.uniform(0.2, 0.8)
    
    seg1_start = [
        px - t1 * scale1 * d1x,
        py - t1 * scale1 * d1y,
        pz - t1 * scale1 * d1z
    ]
    seg1_end = [
        px + t2 * scale1 * d1x,
        py + t2 * scale1 * d1y,
        pz + t2 * scale1 * d1z
    ]
    
    seg2_start = [
        px - s1 * scale2 * d2x,
        py - s1 * scale2 * d2y,
        pz - s1 * scale2 * d2z
    ]
    seg2_end = [
        px + s2 * scale2 * d2x,
        py + s2 * scale2 * d2y,
        pz + s2 * scale2 * d2z
    ]
    
    coordinates = seg1_start + seg1_end + seg2_start + seg2_end
    expected_point = (px, py, pz)
    
    return coordinates, expected_point

def run_main_program(numbers, executable="build/main.exe", expected_point=None):
    if not os.path.exists(executable):
        print(f"Error: Executable '{executable}' not found!")
        print("Please run 'make' first to build the program.")
        return False
        
    args = [str(num) for num in numbers]
    
    cmd = [executable] + args
    
    print("=" * 70)
    print(f"Running: {' '.join(cmd[:3])}... ({len(args)} arguments)")
    print("=" * 70)
    
    try:
        result = subprocess.run(cmd, check=True, text=True, 
                              capture_output=True, encoding='utf-8')
        
        print(result.stdout)
        
        if expected_point is not None:
            print(f"\nExpected intersection point: ({expected_point[0]:.15f}, {expected_point[1]:.15f}, {expected_point[2]:.15f})")
            print("(This is the theoretical intersection point generated by the script)")
        
        if result.stderr:
            print("Stderr:", result.stderr)
        
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"Error running program: {e}")
        print("Stdout:", e.stdout)
        print("Stderr:", e.stderr)
        return False
    except Exception as e:
        print(f"Unexpected error: {e}")
        return False

def main():    
    print("Random Number Generator for Segment Intersection Test")
    print("=" * 70)
    
    mode = input("Choose mode:\n  1 - Random numbers\n  2 - Random intersecting segments\n  Enter choice (1/2): ").strip()
    
    expected_point = None
    
    if mode == "1":
        count = 12
        numbers = generate_random_numbers(count)
        print(f"\nGenerated {count} random numbers:")
        for i, num in enumerate(numbers):
            print(f"  [{i}] = {num}")
    
    elif mode == "2":
        numbers, expected_point = generate_random_intersecting_segments()
        print("\nGenerated two random intersecting segments (12 numbers):")
        print(f"Segment 1: start ({numbers[0]:.3f}, {numbers[1]:.3f}, {numbers[2]:.3f}), "
              f"end ({numbers[3]:.3f}, {numbers[4]:.3f}, {numbers[5]:.3f})")
        print(f"Segment 2: start ({numbers[6]:.3f}, {numbers[7]:.3f}, {numbers[8]:.3f}), "
              f"end ({numbers[9]:.3f}, {numbers[10]:.3f}, {numbers[11]:.3f})")

    else:
        print("Invalid choice!")
        return
    
    print()
    
    success = run_main_program(numbers, expected_point=expected_point)
    
    if success:
        print("\n" + "=" * 70)
        print("Program executed successfully!")
        print("=" * 70)
    else:
        print("\n" + "=" * 70)
        print("Program execution failed!")
        print("=" * 70)
        sys.exit(1)

if __name__ == "__main__":
    main()
